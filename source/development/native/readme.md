# Autolabor PM1 原生应用程序开发指南

## 介绍

原生应用是 Autolabor PM1 支持的首要开发方式。.Net 平台上的 SDK 也依赖于原生 SDK。

所谓*原生（Native）*，指的是不运行在任何虚拟机或程序框架中，而是编译到对应平台的机器码，仅依赖于操作系统即可执行的应用程序或程序库。典型的原生库常常是使用 C 或 C++ 编写，PM1 SDK 也是如此。

## 环境要求

编译 PM1 SDK 需要编译器实现 C++17 的一部分特性，这对应于 **2015 或更高版本的 Visual Studio**，或 **GCC 7.1** 版本以上。同时，SDK 还是需要一些运行库，因此它需要 **Windows 7** 以上。SDK 暂时仍不支持 Linux，但此支持性在计划内。

<a name="体验"></a>

## 体验

对于大部分不准备修改 SDK 源码的用户来说，PM1 SDK 是一系列*顶层函数（top-level function）*，即不属于任何类的函数。这些函数用于与**一台** Autolabor PM1 底盘交互，或为交互逻辑提供支持。

> 要使用 SDK 在一台计算机上控制多个底盘，可以启动多个进程，或者深入 SDK 内部，使用 [`autolabor::pm1::chassis` 类](https://github.com/autolaborcenter/pm1_sdk/blob/master/src/main/internal/chassis.hh)。后者可能需要对 C++ 较为深入的了解并能够编译 C++ 工程。

SDK 中的大部分函数需要与底盘建立*连接*，意思是说，打开并且独占一个串口资源，并且在使用期间保证连接的可用性。查看[“初始化”函数](api-reference/initialize)了解详情。

在连接期间，可以与底盘进行多种多样的数据交互，包括获取底盘上各种虚拟或实际传感器的读数以及控制机器人底盘行驶。

最重要的虚拟传感器是[“里程计”](api-reference/odometry)，这是测量机器人位姿变化的传感器。

有两种方式控制机器人底盘行驶：基于*动作*的控制和*连续*的控制。

*动作*是离散的，每个动作都有开始、运行中、完成或因取消而结束的状态，如同一个*线程*。动作旨在保证**开环控制的准确性**。因此，每个动作的启动和停止会被优化，减小初始状态和惯性对动作的影响。在空载状况下，动作控制可以保证 1cm、1° 以内的偏差，但两个动作之间必须经过一瞬间的完全静止状态，显得不够连贯。

*连续*控制关注行驶的流畅性，尽量追随目标的运动状态行驶，但**不保证每次控制都与目标状态完全一致**。优化算法会对新的指令进行修饰，平滑地过渡到新的状态。如果新的状态是可行的，没有设定过快、不可能达到的速度，机器人能在一段时间后达到新的目标状态，通常情况下这个时间少于 1 秒。

> *动作*和*连续*只是 SDK 为了便于理解和使用所作的人为设定。用户还是可以借助 [`autolabor::pm1::chassis` 类](https://github.com/autolaborcenter/pm1_sdk/blob/master/src/main/internal/chassis.hh)实现“流畅的动作”之类的效果，但是可能需要更多参数。

